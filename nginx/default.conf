proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=STATIC:10m inactive=7d use_temp_path=off;

upstream nextjs_upstream {
  server ceos:3000;
}

server {
  listen       80;
  listen       [::]:80;

  # Aqui a gente define o nome do servidor
  # So vai entrar nesse server block se bater esse nome de domínio
  server_name  ceos.dc.ufc.br;
  server_tokens off;

  # Aqui a gente redireciona para o HTTPS caso o usuario nao esteja usando
  # http vagabundo
  # HTTPS é mais seguro e mais rapido que o HTTP no nosso caso, por causa do SSL e Multiplexing do HTTP2
  return 301 https://$host$request_uri;
}

server {
  listen       443 ssl http2;
  listen       [::]:443 ssl http2;

  # Aqui a gente define o certificado e chave do SSL
  # Isso aqui é gerado pelo certbot e colocado no /etc/nginx/ssl/live/ceos.dc.ufc.br
  ssl_certificate /etc/nginx/ssl/live/ceos.dc.ufc.br/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/ceos.dc.ufc.br/privkey.pem;

  # Locais onde vai ter os logs
  access_log /var/log/nginx/app.access.log;
  error_log /var/log/nginx/app.error.log;

  # Aqui a gente define o nome do servidor
  # So vai entrar nesse server block se bater esse nome de domínio
  server_name  ceos.dc.ufc.br;

  # Retira o nome do NGINX do header
  # Caso exista alguma vulnerabilidade do NGINX, nao vai ser exposta tao facil
  # Porque o nome do NGINX e versao nao vai estar no header
  server_tokens off;

  # Compressao de alguns item que possuem muito text
  # Nunca coloque imagens aqui pois ja sao comprimidas
  gzip on;
  gzip_proxied any;
  gzip_comp_level 2;
  gzip_min_length 1000;
  gzip_types text/plain text/css application/javascript image/svg+xml;

  # Aqui a gente termina o SSL e faz a conexão com o servidor via HTTP 1.1
  # Como a gente não precisa de arquitetura Zero Trust e o TLS handshake é custoso
  # A gente faz o SSL no NGINX e o HTTP no NodeJS
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection 'upgrade';
  proxy_set_header Host $host;
  proxy_cache_bypass $http_upgrade;

  # Isso aqui é para o certbot conseguir fazer o certificado
  # Ele precisa de uma forma de validar que o dominio é seu
  # No nosso caso a gente ta usando HTTP-01 Challenge
  # Entao ele vai criar um arquivo .well-known/acme-challenge
  # E vai colocar um hash dentro dele
  # Entao a gente precisa deixar ele acessar esse arquivo
  # E depois a gente apaga ele
  # Leia mais aqui https://letsencrypt.org/docs/challenge-types/
  location ~ /.well-known/acme-challenge {
    allow all;
    root /var/www/html;
  }

  # Aqui a gente faz o uso do Cache por 60minutos do que tem no NGINX
  # 60 minutos porque as imagens do nextjs não possuem uma nova hash a cada build
  # Entao se a imagem mudar, ela vai ficar atrasada por 60 minutos
  location /images/ {
    proxy_cache STATIC;
    proxy_ignore_headers Cache-Control;
    proxy_cache_valid 60m;

    proxy_pass http://nextjs_upstream;
  }

  # Aqui a gente faz o cache de outros arquivos estaticos como HTML, chunks de JS e CSS
  # Nao precisa setar header aqui porque o NextJS ja coloca pra ficar eterno JS, CSS, HTML
  # Pois eles possuem um id diferente a cada build
  # Entao nao precisa ficar invalidando o cache a cada build
  location /_next/static {
    proxy_cache STATIC;
    proxy_pass http://nextjs_upstream;
  }

  # Aqui a gente serve o resto dos arquivos com o proprio nextjs
  location / {
    proxy_pass http://nextjs_upstream;
  }
}
